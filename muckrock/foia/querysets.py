"""
QuerySets for the FOIA application
"""

# Django
from django.contrib.auth.models import AnonymousUser
from django.db import models
from django.db.models import Case, Count, F, Max, Q, Sum, When
from django.db.models.functions import Cast, Now
from django.utils import timezone
from django.utils.text import slugify

# Standard Library
from datetime import date, datetime, time

# MuckRock
from muckrock.models import ExtractDay


# XXX go through these
class FOIARequestQuerySet(models.QuerySet):
    """Object manager for FOIA requests"""

    # pylint: disable=too-many-public-methods

    def get_done(self):
        """Get all FOIA requests with responses"""
        return (
            self.filter(status__in=['partial', 'done'])
            .exclude(datetime_done=None)
        )

    def get_viewable(self, user):
        """Get all viewable FOIA requests for given user"""

        if user.is_staff:
            return self.all()

        if user.is_authenticated():
            # Requests are visible if you own them, have view or edit permissions,
            # or if they are not embargoed
            query = (
                Q(composer__user=user) | Q(edit_collaborators=user)
                | Q(read_collaborators=user) | ~Q(embargo=True)
            )
            # agency users may also view requests for their agency
            if user.profile.acct_type == 'agency':
                query = query | Q(agency=user.profile.agency)
            # organizational users may also view requests from their org that are shared
            if user.profile.organization is not None:
                query = query | Q(
                    composer__user__profile__org_share=True,
                    composer__user__profile__organization=user.profile.
                    organization,
                )
            return self.filter(query)
        else:
            # anonymous user, filter out embargoes
            return self.exclude(embargo=True)

    def get_public(self):
        """Get all publically viewable FOIA requests"""
        return self.get_viewable(AnonymousUser())

    def get_overdue(self):
        """Get all overdue FOIA requests"""
        return self.filter(
            status__in=['ack', 'processed'], date_due__lt=date.today()
        )

    def get_followup(self):
        """Get requests that need follow up emails sent"""
        return (
            self.filter(
                status__in=['ack', 'processed'],
                date_followup__lte=date.today(),
                disable_autofollowups=False,
            )
            # Exclude requests which should be emailed or faxed,
            # but need to have their email address or fax number updated.
            # This is to not overwhelm snail mail tasks with autogenerated
            # messages while trying to find new contact info
            .exclude(
                Q(email__status='error', fax=None)
                | Q(email=None, fax__status='error')
                | Q(email__status='error', fax__status='error')
            )
        )

    def get_open(self):
        """Get requests which we are awaiting a response from"""
        return self.filter(status__in=['ack', 'processed', 'appealing'])

    def organization(self, organization):
        """Get requests belonging to an organization's members."""
        return (
            self.select_related(
                'agency', 'jurisdiction', 'jurisdiction__parent',
                'jurisdiction__parent__parent'
            ).filter(composer__user__profile__organization=organization)
            .order_by('-composer__datetime_submitted')
        )

    def select_related_view(self):
        """Select related models for viewing"""
        return self.select_related(
            'agency__jurisdiction__parent__parent',
            'composer__user',
            'crowdfund',
        )

    def get_public_file_count(self, limit=None):
        """Annotate the public file count"""
        foia_qs = self
        count_qs = (
            self._clone().values_list('id').filter(
                communications__files__access='public'
            ).annotate(Count('communications__files'))
        )
        if limit is not None:
            foia_qs = foia_qs[:limit]
            count_qs = count_qs[:limit]
        counts = dict(count_qs)
        foias = []
        for foia in foia_qs:
            foia.public_file_count = counts.get(foia.pk, 0)
            foias.append(foia)
        return foias

    def get_stale(self, agency=None):
        """Load requests for a stale agency"""
        foia_qs = (
            self.get_open().annotate(
                latest_response=ExtractDay(
                    Cast(
                        Now() - Max(
                            Case(
                                When(
                                    communications__response=True,
                                    then='communications__datetime'
                                )
                            )
                        ),
                        models.DurationField(),
                    )
                )
            ).order_by('-latest_response')
            .select_related('agency__jurisdiction')
        )
        if agency is not None:
            foia_qs = foia_qs.filter(agency=agency)
        return foia_qs

    def get_featured(self, user):
        """Get featured requests"""
        return (
            self.get_viewable(user).filter(featured=True)
            .select_related_view().get_public_file_count()
        )

    def get_processing_days(self):
        """Get the number of processing days"""
        return (
            self.filter(status='submitted').exclude(date_processing=None)
            .aggregate(days=Sum(date.today() - F('date_processing')))['days']
        )

    def get_submitted_range(self, start, end):
        """Get requests submitted within a date range"""
        return self.filter(composer__datetime_submitted__range=(start, end))

    def get_today(self):
        """Get requests submitted today"""
        midnight = time(tzinfo=timezone.get_current_timezone())
        today_midnight = datetime.combine(date.today(), midnight)
        return self.filter(composer__datetime_submitted__gte=today_midnight)

    def exclude_org_users(self):
        """Exclude requests made by org users"""
        return self.exclude(
            composer__user__profile__organization__active=True,
            composer__user__profile__organization__monthly_cost__gt=0,
        )

    def create_new(self, composer, agency, contact_info=None):
        """Create a new request and submit it"""
        # TODO title ??
        if composer.agencies.count() > 1:
            title = '%s (%s)' % (composer.title, agency.name)
        else:
            title = composer.title
        if agency.jurisdiction.days:
            calendar = agency.jurisdiction.get_calendar()
            date_due = calendar.business_days_from(
                date.today(),
                agency.jurisdiction.days,
            )
        else:
            date_due = None
        proxy_info = agency.get_proxy_info()
        foia = self.create(
            status='submitted',
            title=title,
            slug=slugify(title),
            agency=agency,
            embargo=composer.embargo,
            composer=composer,
            date_due=date_due,
            missing_proxy=proxy_info['missing_proxy'],
        )
        foia.tags.set(*composer.tags.all())
        foia.create_initial_communication(
            proxy_info.get('from_user', composer.user),
            proxy=proxy_info['proxy'],
        )
        foia.process_attachments(composer.user, composer=True)
        foia.submit(contact_info=contact_info)


class FOIAComposerQuerySet(models.QuerySet):
    """Custom Query Set for FOIA Composers"""

    def get_viewable(self, user):
        """Return all composers viewable to the user"""
        # TODO rethink this
        # test this
        # embargo should be 'all foias are embargoed'?
        if user.is_staff:
            return self.all()

        if user.is_authenticated():
            query = Q(user=user) | (~Q(status='started') & ~Q(embargo=True))
            # organizational users may also view requests from their org that are shared
            if user.profile.organization is not None:
                query = query | Q(
                    user__profile__org_share=True,
                    user__profile__organization=user.profile.organization,
                )
            return self.filter(query)
        else:
            # anonymous user, filter out drafts and embargoes
            return self.exclude(status='started').exclude(embargo=True)

    def get_or_create_draft(self, user):
        """Return an existing blank draft or create one"""
        draft = self.filter(
            user=user,
            title='Untitled',
            slug='untitled',
            status='started',
            agencies=None,
            requested_docs='',
            edited_boilerplate=False,
            datetime_submitted=None,
            embargo=False,
            parent=None,
            tags=None,
            num_org_requests=0,
            num_monthly_requests=0,
            num_reg_requests=0,
        ).first()
        if draft:
            draft.datetime_created = timezone.now()
            draft.save()
            return draft
        else:
            return self.create(user=user)
