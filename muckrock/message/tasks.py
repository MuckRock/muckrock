"""
Tasks for the messages application.
"""

from django.contrib.auth.models import User
from django.core.urlresolvers import reverse

from celery.schedules import crontab
from celery.task import periodic_task, task
from dateutil.relativedelta import relativedelta
import logging
import stripe

from muckrock.accounts.models import Profile
from muckrock.message.email import TemplateEmail
from muckrock.message import digests, notifications, receipts
from muckrock.organization.models import Organization

logger = logging.getLogger(__name__)

def send_activity_digest(subject, preference, interval):
    """Helper to send out timed digests"""
    profiles = Profile.objects.select_related('user').filter(email_pref=preference).distinct()
    for profile in profiles:
        # for now, only send experimental users the new updates
        if profile.experimental:
            email = digests.ActivityDigest(
                user=profile.user,
                interval=interval,
                subject=subject
            )
            email.send()
        else:
            profile.send_notifications()

# every hour
@periodic_task(run_every=crontab(hour='*/1', minute=0), name='muckrock.message.tasks.hourly_digest')
def hourly_digest():
    """Send out hourly digest"""
    send_activity_digest(u'Hourly Digest', 'hourly', relativedelta(hours=1))

# every day at 10am
@periodic_task(run_every=crontab(hour=10, minute=0), name='muckrock.message.tasks.daily_digest')
def daily_digest():
    """Send out daily digest"""
    send_activity_digest(u'Daily Digest', 'daily', relativedelta(days=1))

# every Monday at 10am
@periodic_task(
    run_every=crontab(day_of_week=1, hour=10, minute=0),
    name='muckrock.message.tasks.weekly_digest')
def weekly_digest():
    """Send out weekly digest"""
    send_activity_digest(u'Weekly Digest', 'weekly', relativedelta(weeks=1))

# first day of every month at 10am
@periodic_task(
    run_every=crontab(day_of_month=1, hour=10, minute=0),
    name='muckrock.message.tasks.monthly_digest')
def monthly_digest():
    """Send out monthly digest"""
    send_activity_digest(u'Monthly Digest', 'monthly', relativedelta(months=1))

# every day at 9:30am
@periodic_task(run_every=crontab(hour=9, minute=30), name='muckrock.message.tasks.staff_digest')
def staff_digest():
    """Send out staff digest"""
    staff_users = User.objects.filter(is_staff=True).distinct()
    for staff_user in staff_users:
        email = digests.StaffDigest(user=staff_user, subject=u'Daily Staff Digest')
        email.send()

@task(name='muckrock.message.tasks.send_invoice_receipt')
def send_invoice_receipt(invoice_id):
    """Send out a receipt for an invoiced charge"""
    invoice = stripe.Invoice.retrieve(invoice_id)
    try:
        charge = stripe.Charge.retrieve(invoice.charge)
    except stripe.error.InvalidRequestError:
        # a free subscription has no charge attached
        # maybe send a notification about the renewal
        # but for now just handle the error
        return
    profile = Profile.objects.get(customer_id=invoice.customer)
    # send a receipt based on the plan
    customer = profile.customer()
    subscription = customer.subscriptions.retrieve(invoice.subscription)
    try:
        receipt_classes = {
            'pro': receipts.ProSubscriptionReceipt,
            'org': receipts.OrgSubscriptionReceipt
        }
        receipt_class = receipt_classes[subscription.plan.id]
    except KeyError:
        logger.warning('Invoice charged for unrecognized plan: %s', subscription.plan.name)
        receipt_class = receipts.GenericReceipt
    receipt = receipt_class(profile.user, charge)
    receipt.send(fail_silently=False)

@task(name='muckrock.message.tasks.send_charge_receipt')
def send_charge_receipt(charge_id):
    """Send out a receipt for a charge"""
    charge = stripe.Charge.retrieve(charge_id)
    # if the charge was generated by an invoice, let the invoice handler send the receipt
    if charge.invoice:
        return
    # we should expect charges to have metadata attached when they are made
    try:
        user_email = charge.metadata['email']
        user_action = charge.metadata['action']
    except KeyError:
        logger.warning('Malformed charge metadata, no receipt sent: %s', charge)
        return
    # try getting the user based on the provided email
    # we know from Checkout purchases that logged in users have their email autofilled
    try:
        user = User.objects.get(email=user_email)
    except User.DoesNotExist:
        user = None
    # every charge type should have a corresponding receipt class
    # if there is a charge type without a class, fallback to a generic receipt
    # this list of receipt classes should be made into a setting...later
    try:
        receipt_classes = {
            'request-purchase': receipts.RequestPurchaseReceipt,
            'request-fee': receipts.RequestFeeReceipt,
            'request-multi': receipts.MultiRequestReceipt,
            'crowdfund-payment': receipts.CrowdfundPaymentReceipt,
        }
        receipt_class = receipt_classes[user_action]
    except KeyError:
        receipt_class = receipts.GenericReceipt
    receipt = receipt_class(user, charge)
    receipt.send(fail_silently=False)

def get_subscription_type(invoice):
    """Gets the subscription type from the invoice."""
    # get the first line of the invoice
    lines = invoice.lines
    subscription_type = 'unknown'
    if lines.total_count > 0:
        data = lines.data
        plan = data[0].plan
        subscription_type = plan.id
    return subscription_type

@task(name='muckrock.message.tasks.failed_payment')
def failed_payment(invoice_id):
    """Notify a customer about a failed subscription invoice."""
    invoice = stripe.Invoice.retrieve(invoice_id)
    attempt = invoice.attempt_count
    subscription_type = get_subscription_type(invoice)
    profile = Profile.objects.get(customer_id=invoice.customer)
    user = profile.user
    # raise the failed payment flag on the profile
    profile.payment_failed = True
    profile.save()
    subject = u'Your payment has failed'
    org = None
    if subscription_type == 'org':
        org = Organization.objects.get(owner=user)
    if attempt == 4:
        # on last attempt, cancel the user's subscription and lower the failed payment flag
        if subscription_type == 'pro':
            profile.cancel_pro_subscription()
        elif subscription_type == 'org':
            org.cancel_subscription()
        profile.payment_failed = False
        profile.save()
        logger.info('%s subscription has been cancelled due to failed payment', user.username)
        subject = u'Your %s subscription has been cancelled' % subscription_type
        context = {
            'attempt': 'final',
            'type': subscription_type,
            'org': org
        }
    else:
        logger.info('Failed payment by %s, attempt %s', user.username, attempt)
        context = {
            'attempt': attempt,
            'type': subscription_type,
            'org': org
        }
    notification = TemplateEmail(
        user=user,
        extra_context=context,
        text_template='message/notification/failed_payment.txt',
        html_template='message/notification/failed_payment.html',
        subject=subject,

    )
    notification.send(fail_silently=False)

@task(name='muckrock.message.tasks.welcome')
def welcome(user):
    """Send a welcome notification to a new user. Hello!"""
    verification_url = reverse('acct-verify-email')
    key = user.profile.generate_confirmation_key()
    context = {'verification_link': user.profile.wrap_url(verification_url, key=key)}
    notification = notifications.WelcomeNotification(user, context)
    notification.send(fail_silently=False)

@task(name='muckrock.message.tasks.gift')
def gift(to_user, from_user, gift_description):
    """Notify the user when they have been gifted requests."""
    context = {
        'from': from_user,
        'gift': gift_description
    }
    notification = notifications.GiftNotification(to_user, context)
    notification.send(fail_silently=False)

@task(name='muckrock.message.tasks.email_change')
def email_change(user, old_email):
    """Notify the user when their email is changed."""
    context = {
        'old_email': old_email,
        'new_email': user.email
    }
    notification = notifications.EmailChangeNotification(user, context)
    notification.to.append(old_email) # Send to both the new and old email addresses
    notification.send(fail_silently=False)
